type singleWithId = {
  id: int,
  options: list(Hero.Activatable.option),
  level: Maybe.t(int),
  customCost: Maybe.t(int),
};

/**
 * Is an Activatable entry active?
 */
let isActive = (x: Hero.Activatable.t) => ListH.Extra.notNull(x.active);

module Convert = {
  open Maybe;

  let heroEntryToSingles = (x: Hero.Activatable.t) =>
    x.active
    |> ListH.map((s: Hero.Activatable.single) =>
         {
           id: x.id,
           options: s.options,
           level: s.level,
           customCost: s.customCost,
         }
       );
  /* /**
    * Converts the object generated by the list item to an object that can be
    * inserted into an array of ActiveObjects.
    * @param obj The entry for which you want to convert the object.
    * @param activate The object generated by the list item.
    */
   export const convertUIStateToActiveObject =
     (activate: Record<ActivatableActivationOptions>): Record<ActiveObject> => {
       const id = AAOA.id (activate)
       const selectOptionId1 = AAOA.selectOptionId1 (activate)
       const selectOptionId2 = AAOA.selectOptionId2 (activate)
       const selectOptionId3 = AAOA.selectOptionId3 (activate)
       const input = AAOA.input (activate)
       const level = AAOA.level (activate)
       const customCost = AAOA.customCost (activate)

       return id === AdvantageId.HatredOf
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: input,
             cost: customCost,
           })
         : id === DisadvantageId.PersonalityFlaw
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: or (fmap (elemF (List<number | string> (7, 8)))
                           (selectOptionId1))
               ? input
               : Nothing,
             cost: customCost,
           })
         : id === SpecialAbilityId.SkillSpecialization
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: alt<number | string> (input)
                                       (selectOptionId2),
             cost: customCost,
           })
         : isJust (input) && isJust (selectOptionId1)
         ? ActiveObject ({
             sid: selectOptionId1,
             sid2: input,
             sid3: selectOptionId2,
             tier: level,
             cost: customCost,
           })
         : ActiveObject ({
             sid: alt<number | string> (input)
                                       (selectOptionId1),
             sid2: then (guard (isJust (input) || isJust (selectOptionId1)))
                       (selectOptionId2),
             sid3: selectOptionId3,
             tier: level,
             cost: customCost,
           })
     } */
  /* /**
    * Generates a list of ActiveObjects based on the given instance.
    */
   export const convertActivatableToArray =
     (x: Record<ActivatableDependent>) =>
       pipe_ (
               x,
               ADA.active,
               imap (index => toActiveObjectWithId (index) (ADA.id (x)))
             ) */
  /* /**
    * Get all active items in an array.
    * @param state A state slice.
    */
   export const getActiveFromState =
     foldr (pipe (convertActivatableToArray, append)) (empty)

   export interface ActiveObjectAny extends ActiveObject {
     [key: string]: any
   } */

  let activatableOptionToSelectOptionId =
      (id: Hero.Activatable.option): maybe(Ids.selectOptionId) =>
    switch (id) {
    | `Generic(x) => Just(`Generic(x))
    | `Skill(x) => Just(`Skill(x))
    | `CombatTechnique(x) => Just(`CombatTechnique(x))
    | `Spell(x) => Just(`Spell(x))
    | `Cantrip(x) => Just(`Cantrip(x))
    | `LiturgicalChant(x) => Just(`LiturgicalChant(x))
    | `Blessing(x) => Just(`Blessing(x))
    | `CustomInput(_) => Nothing
    };
};

module SelectOptions = {
  open Static.SelectOption;
  open Maybe;
  open Maybe.Functor;

  let x = 3 + 4;
  let y = 3 + 4;

  /**
   * Get a selection option with the given id from given wiki entry. Returns
   * `Nothing` if not found.
   */
  let getSelectOption = (x: Static.activatable, id: Hero.Activatable.option) =>
    Maybe.Monad.(
      id
      |> Convert.activatableOptionToSelectOptionId
      >>= Function.flip(
            SelectOptionMap.lookup,
            switch (x) {
            | Advantage(y) => y.selectOptions
            | Disadvantage(y) => y.selectOptions
            | SpecialAbility(y) => y.selectOptions
            },
          )
    );

  /**
   * Get a selection option's name with the given id from given wiki entry.
   * Returns `Nothing` if not found.
   */
  let getSelectOptionName = (x, id) =>
    id |> getSelectOption(x) <&> (y => y.name);

  /**
   * Get a selection option's cost with the given id from given wiki entry.
   * Returns `Nothing` if not found.
   */
  let getSelectOptionCost = (x, id) =>
    id |> getSelectOption(x) <&> (y => y.cost);

  /**
   * Get all first select option IDs from the given entry.
   */
  let getActiveSelections = (x: Hero.Activatable.t) =>
    x.active
    |> mapMaybe((y: Hero.Activatable.single) => y.options |> listToMaybe);
  // type SecondarySelections = OrderedMap<number | string, List<string | number>>
  //
  // /**
  //  * Get all `ActiveObject.sid2` values from the given instance, sorted by
  //  * `ActiveObject.sid` in Map.
  //  * @param entry
  //  */
  // export const getActiveSecondarySelections =
  //   fmap (pipe (
  //               ADA.active,
  //               foldl ((map: SecondarySelections) => (selection: Record<ActiveObject>) =>
  //                       fromMaybe (map)
  //                                 (liftM2<string | number, string | number, SecondarySelections>
  //                                   (id => id2 => alter<List<string | number>>
  //                                     (pipe (
  //                                       fmap (consF (id2)),
  //                                       altF (Just (List (id2)))
  //                                     ))
  //                                     (id)
  //                                     (map))
  //                                   (AOA.sid (selection))
  //                                   (AOA.sid2 (selection))))
  //                     (OrderedMap.empty)
  //             ))
  //
  // /**
  //  * Get all `DependencyObject.sid` values from the given instance.
  //  * @param obj The entry.
  //  */
  // export const getRequiredSelections:
  //   (m: Maybe<Record<ActivatableDependent>>) => Maybe<List<string | number | List<number>>> =
  //     fmap (pipe (
  //       ADA.dependencies,
  //       mapMaybe<ActivatableDependency, string | number | List<number>> (pipe (
  //         ensure (isRecord),
  //         bindF (DependencyObject.A.sid)
  //       ))
  //     ))
};

module Names = {
  open Maybe;
  open Maybe.Functor;
  open Maybe.Monad;
  open Static;
  open Function;

  /* /**
    * Returns the name of the given object. If the object is a string, it returns
    * the string.
    */
   export const getFullName =
     (obj: string | Record<ActiveActivatable>): string => {
       if (typeof obj === "string") {
         return obj
       }

       return AAA_.name (obj)
     }

   /**
    * Accepts the full special ability name and returns only the text between
    * parentheses. If no parentheses were found, returns an empty string.
    */
   export const getBracketedNameFromFullName =
     (full_name: string): string => {
       const result = /\((?<subname>.+)\)/u .exec (full_name)

       if (result === null || result .groups === undefined) {
         return ""
       }

       return result .groups .subname
     }*/

  let%private getOption1 = heroEntry => heroEntry.options |> listToMaybe;
  let%private getOption2 = heroEntry => ListH.(heroEntry.options <!!> 1);

  let%private getCustomInput = (option: Hero.Activatable.option) =>
    switch (option) {
    | `CustomInput(x) => Just(x)
    | `Generic(_)
    | `Skill(_)
    | `CombatTechnique(_)
    | `Spell(_)
    | `LiturgicalChant(_)
    | `Cantrip(_)
    | `Blessing(_) => Nothing
    };

  let%private getGenericId = (option: Hero.Activatable.option) =>
    switch (option) {
    | `Generic(x) => Just(x)
    | `Skill(_)
    | `CombatTechnique(_)
    | `Spell(_)
    | `LiturgicalChant(_)
    | `Cantrip(_)
    | `Blessing(_)
    | `CustomInput(_) => Nothing
    };

  let%private lookupMap = (k, mp, f) => f <$> IntMap.lookup(k, mp);

  let%private getSkillFromOption =
              (staticData, option: Hero.Activatable.option) =>
    switch (option) {
    | `Skill(id) => IntMap.lookup(id, staticData.skills)
    | `Generic(_)
    | `CombatTechnique(_)
    | `Spell(_)
    | `LiturgicalChant(_)
    | `Cantrip(_)
    | `Blessing(_)
    | `CustomInput(_) => Nothing
    };

  /**
   * A lot of entries have customization options: Text input, select option or
   * both. This function creates a string that can be appended to the `name`
   * property of the respective record to create the full active name.
   */
  let getEntrySpecificNameAddition = (staticData, staticEntry, heroEntry) =>
    switch (staticEntry) {
    | Advantage(entry) =>
      switch (Ids.AdvantageId.fromInt(entry.id)) {
      | Aptitude
      | ExceptionalSkill =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `Skill(id) => lookupMap(id, staticData.skills, x => x.name)
            | `Spell(id) => lookupMap(id, staticData.spells, x => x.name)
            | `LiturgicalChant(id) =>
              lookupMap(id, staticData.liturgicalChants, x => x.name)
            | `Generic(_)
            | `CombatTechnique(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => Nothing
            }
        )
      | ExceptionalCombatTechnique
      | WeaponAptitude =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `CombatTechnique(id) =>
              lookupMap(id, staticData.combatTechniques, x => x.name)
            | `Generic(_)
            | `Skill(_)
            | `Spell(_)
            | `LiturgicalChant(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => Nothing
            }
        )
      | HatredOf =>
        heroEntry
        |> getOption1
        >>= SelectOptions.getSelectOption(staticEntry)
        |> liftM2(
             (type_, frequency: Static.SelectOption.t) =>
               type_ ++ " (" ++ frequency.name ++ ")",
             getOption2(heroEntry) >>= getCustomInput,
           )
      | _ => Nothing
      }
    | Disadvantage(entry) =>
      switch (Ids.DisadvantageId.fromInt(entry.id)) {
      | Incompetent =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        <&> (x => x.name)
      | PersonalityFlaw =>
        heroEntry
        |> getOption1
        >>= SelectOptions.getSelectOption(staticEntry)
        <&> (
          option1 =>
            (
              switch (option1.id) {
              // Get the input if Prejudice or Unworldly is selected
              | `Generic(7 | 8) => heroEntry |> getOption2 >>= getCustomInput
              // Otherwise ignore any additional options
              | `Generic(_)
              | `Skill(_)
              | `CombatTechnique(_)
              | `Spell(_)
              | `LiturgicalChant(_)
              | `Cantrip(_)
              | `Blessing(_) => Nothing
              }
            )
            |> maybe(option1.name, specialInput =>
                 option1.name ++ ": " ++ specialInput
               )
        )
      | _ => Nothing
      }
    | SpecialAbility(entry) =>
      switch (Ids.SpecialAbilityId.fromInt(entry.id)) {
      | AdaptionZauber
      | FavoriteSpellwork =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `Spell(id) => lookupMap(id, staticData.spells, x => x.name)
            | `Generic(_)
            | `Skill(_)
            | `CombatTechnique(_)
            | `LiturgicalChant(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => Nothing
            }
        )
      | TraditionSavant
      | Forschungsgebiet
      | Expertenwissen
      | Wissensdurst
      | Recherchegespuer =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        <&> (x => x.name)
      | Lieblingsliturgie =>
        heroEntry
        |> getOption1
        >>= (
          sid =>
            switch (sid) {
            | `LiturgicalChant(id) =>
              lookupMap(id, staticData.liturgicalChants, x => x.name)
            | `Generic(_)
            | `Skill(_)
            | `CombatTechnique(_)
            | `Spell(_)
            | `Cantrip(_)
            | `Blessing(_)
            | `CustomInput(_) => Nothing
            }
        )
      | SkillSpecialization =>
        heroEntry
        |> getOption1
        >>= getSkillFromOption(staticData)
        >>= (
          skill =>
            heroEntry
            |> getOption2
            >>= (
              option2 =>
                (
                  switch (option2) {
                  // If input string use input
                  | `CustomInput(x) => Just(x)
                  // Otherwise lookup application name
                  | `Generic(id) =>
                    skill.applications
                    |> IntMap.Foldable.find((a: Skill.application) =>
                         a.id === id
                       )
                    <&> (a => a.name)
                  | `Skill(_)
                  | `CombatTechnique(_)
                  | `Spell(_)
                  | `LiturgicalChant(_)
                  | `Cantrip(_)
                  | `Blessing(_) => Nothing
                  }
                )
                // Merge skill name and application name
                <&> (appName => skill.name ++ ": " ++ appName)
            )
        )
      | Exorzist =>
        switch (heroEntry.level) {
        | Just(1) =>
          heroEntry
          |> getOption1
          >>= SelectOptions.getSelectOptionName(staticEntry)
        | _ => Nothing
        }
      | SpellEnhancement as entryId
      | ChantEnhancement as entryId =>
        heroEntry
        |> getOption1
        >>= SelectOptions.getSelectOption(staticEntry)
        >>= (
          enhancement =>
            enhancement.target
            >>= (
              id =>
                (
                  switch (entryId) {
                  | SpellEnhancement =>
                    IntMap.lookup(id, staticData.spells) <&> (x => x.name)
                  | _ =>
                    IntMap.lookup(id, staticData.liturgicalChants)
                    <&> (x => x.name)
                  }
                )
                <&> (targetName => targetName ++ ": " ++ enhancement.name)
            )
        )
      | TraditionArcaneBard =>
        heroEntry
        |> getOption1
        >>= getGenericId
        >>= flip(IntMap.lookup, staticData.arcaneBardTraditions)
      | TraditionArcaneDancer =>
        heroEntry
        |> getOption1
        >>= getGenericId
        >>= flip(IntMap.lookup, staticData.arcaneDancerTraditions)
      | LanguageSpecializations =>
        liftM2(
          SelectOptions.getSelectOption,
          IntMap.lookup(
            Ids.SpecialAbilityId.toInt(Language),
            staticData.specialAbilities,
          )
          <&> (specialAbility => SpecialAbility(specialAbility)),
          getOption1(heroEntry),
        )
        |> join
        >>= (
          language =>
            heroEntry
            |> getOption2
            >>= (
              option2 =>
                (
                  switch (option2) {
                  | `CustomInput(str) => Just(str)
                  | `Generic(specializationId) =>
                    language.specializations
                    >>= (
                      specializations =>
                        ListH.(specializations <!!> specializationId - 1)
                    )
                  | `Skill(_)
                  | `CombatTechnique(_)
                  | `Spell(_)
                  | `LiturgicalChant(_)
                  | `Cantrip(_)
                  | `Blessing(_) => Nothing
                  }
                )
                <&> (specialization => language.name ++ ": " ++ specialization)
            )
        )
      | _ => Nothing
      }
    };
  /*
   const getEntrySpecificNameAddition =
     (staticData: StaticDataRecord) =>
     (wiki_entry: Activatable) =>
     (hero_entry: Record<ActiveObjectWithId>): Maybe<string> => {
       switch (AOWIA.id (hero_entry)) {
         // Entry with Skill selection (string id)
         case AdvantageId.aptitude:
         case AdvantageId.exceptionalSkill:
         case AdvantageId.exceptionalCombatTechnique:
         case AdvantageId.weaponAptitude:
         case DisadvantageId.incompetent:
         case SpecialAbilityId.adaptionZauber:
         case SpecialAbilityId.favoriteSpellwork:
         case SpecialAbilityId.forschungsgebiet:
         case SpecialAbilityId.expertenwissen:
         case SpecialAbilityId.wissensdurst:
         case SpecialAbilityId.recherchegespuer:
         case SpecialAbilityId.lieblingsliturgie:
           return pipe (
                         AOWIA.sid,
                         misStringM,
                         bindF (getWikiEntry (staticData)),
                         bindF<EntryWithCategory, SkillishEntry> (ensure (isSkillishWikiEntry)),
                         fmap (SAL.name)
                       )
                       (hero_entry)

         case AdvantageId.hatredOf:
           return pipe (
                         AOWIA.sid,
                         findSelectOption (wiki_entry),
                         liftM2 ((type: string | number) => (frequency: Record<SelectOption>) =>
                                 `${type} (${SOA.name (frequency)})`)
                               (AOWIA.sid2 (hero_entry))
                       )
                       (hero_entry)

         case DisadvantageId.personalityFlaw:
           return pipe (
                         AOWIA.sid,
                         getSelectOptionName (wiki_entry),
                         fmap (option_name => maybe (option_name)

                                                   // if there is additional input, add to name
                                                   ((specialInput: string | number) =>
                                                     `${option_name}: ${specialInput}`)
                                                   (pipe (
                                                           AOWIA.sid,

                                                           // Check if the select option allows
                                                           // additional input
                                                           bindF<SID, number> (
                                                             ensure (
                                                               (x): x is number => isNumber (x)
                                                                 && elem (x) (List (7, 8))
                                                             )
                                                           ),
                                                           bindF (() => AOWIA.sid2 (hero_entry))
                                                         )
                                                         (hero_entry)))
                       )
                       (hero_entry)

         case SpecialAbilityId.skillSpecialization:
           return pipe (
                         AOWIA.sid,
                         misStringM,
                         bindF (lookupF (SDA.skills (staticData))),
                         bindF (skill => pipe (
                                           AOWIA.sid2,

                                           // If input string use input
                                           misStringM,

                                           // Otherwise lookup application name
                                           altF_ (() => pipe (
                                                               SA.applications,
                                                               find<Record<Application>> (pipe (
                                                                 Application.AL.id,
                                                                 elemF (AOWIA.sid2 (hero_entry))
                                                               )),
                                                               fmap (AA.name)
                                                             )
                                                             (skill)),

                                           // Merge skill name and application name
                                           fmap (appl => `${SA.name (skill)}: ${appl}`)
                                         )
                                         (hero_entry))
                       )
                       (hero_entry)

         case SpecialAbilityId.exorzist:
           return pipe_ (
             hero_entry,
             AOWIA.tier,
             Maybe.product,
             ensure (equals (1)),
             thenF (AOWIA.sid (hero_entry)),
             findSelectOption (wiki_entry),
             fmap (SOA.name)
           )

         case prefixSA (SpecialAbilityId.spellEnhancement):
         case prefixSA (SpecialAbilityId.chantEnhancement):
           return pipe (
                         AOWIA.sid,
                         findSelectOption (wiki_entry),
                         bindF (ext => pipe (
                                             bindF ((target_id: string) => {
                                               const acc =
                                                 AOWIA.id (hero_entry)
                                                 === prefixSA (SpecialAbilityId.spellEnhancement)
                                                   ? SDA.spells
                                                   : SDA.liturgicalChants

                                               return lookupF<string, ActivatableSkillEntry>
                                                 (acc (staticData))
                                                 (target_id)
                                             }),
                                             fmap (
                                               target_entry =>
                                                 `${SAL.name (target_entry)}: ${SOA.name (ext)}`
                                             )
                                           )
                                           (SOA.target (ext)))
                       )
                       (hero_entry)

         case SpecialAbilityId.traditionArcaneBard: {
           return pipe (
                         AOWIA.sid2,
                         misNumberM,
                         bindF (lookupF (SDA.arcaneBardTraditions (staticData))),
                         fmap (NumIdName.A.name)
                       )
                       (hero_entry)
         }

         case SpecialAbilityId.traditionArcaneDancer: {
           return pipe (
                         AOWIA.sid2,
                         misNumberM,
                         bindF (lookupF (SDA.arcaneDancerTraditions (staticData))),
                         fmap (NumIdName.A.name)
                       )
                       (hero_entry)
         }

         case SpecialAbilityId.traditionSavant:
           return pipe (
                         AOWIA.sid,
                         misStringM,
                         bindF (lookupF (SDA.skills (staticData))),
                         fmap (SA.name)
                       )
                       (hero_entry)

         case SpecialAbilityId.languageSpecializations:
           return pipe (
                         SDA.specialAbilities,
                         lookup<string> (SpecialAbilityId.language),
                         bindF (pipe (
                           findSelectOption,
                           thrush (AOWIA.sid (hero_entry))
                         )),
                         bindF (lang => pipe (
                                               AOWIA.sid2,
                                               bindF (
                                                 ifElse<string | number, string>
                                                   (isString)
                                                   <Maybe<string>>
                                                   (Just)
                                                   (spec_id => bind (SOA.specializations (lang))
                                                                   (subscriptF (spec_id - 1)))
                                               ),
                                               fmap (spec => `${SOA.name (lang)}: ${spec}`)
                                             )
                                             (hero_entry))
                       )
                       (staticData)

         case SpecialAbilityId.fachwissen: {
           const getApp = (getSid: (r: Record<ActiveObjectWithId>) => Maybe<string | number>) =>
                           pipe (
                             SA.applications,
                             filter (pipe (AA.prerequisite, isNothing)),
                             find (pipe (AA.id, elemF (getSid (hero_entry)))),
                             fmap (AA.name)
                           )

           return pipe_ (
             hero_entry,
             AOWIA.sid,
             misStringM,
             bindF (lookupF (SDA.skills (staticData))),
             bindF (skill => pipe_ (
                               List (
                                 getApp (AOWIA.sid2) (skill),
                                 getApp (AOWIA.sid3) (skill)
                               ),
                               catMaybes,
                               ensure (xs => flength (xs) === 2),
                               fmap (pipe (
                                 sortStrings (staticData),
                                 formatList ("conjunction") (staticData),
                                 apps => `${SA.name (skill)}: ${apps}}`
                               ))
                             ))
           )
         }

         default: {
           const current_sid = AOWIA.sid (hero_entry)
           const current_sid2 = AOWIA.sid2 (hero_entry)

           // Text input
           if (isJust (AAL.input (wiki_entry)) && any (isString) (current_sid)) {
             return current_sid
           }

           // Select option and text input
           if (isJust (AAL.select (wiki_entry))
               && isJust (AAL.input (wiki_entry))
               && isJust (current_sid)
               && any (isString) (current_sid2)) {
             const name1 = fromMaybe ("") (getSelectOptionName (wiki_entry) (current_sid))
             const name2 = fromJust (current_sid2)

             return Just (`${name1}: ${name2}`)
           }

           // Plain select option
           if (isJust (AAL.select (wiki_entry))) {
             return getSelectOptionName (wiki_entry) (current_sid)
           }

           return Nothing
         }
       }
     }

   const addSndinParenthesis = (snd: string) => replaceStr (")") (`: ${snd})`)

   /**
    * Some entries cannot use the default `name` property from wiki entries. The
    * value returned by may not use the default `name` property. For all entries
    * that do not need to handle a specific display format, the default `name`
    * property is used.
    */
   const getEntrySpecificNameReplacements =
     (staticData: StaticDataRecord) =>
     (wiki_entry: Activatable) =>
     (hero_entry: Record<ActiveObjectWithId>) =>
     (mname_add: Maybe<string>): string => {
       const def = fromMaybe (AAL.name (wiki_entry))

       const maybeMap = (f: (x: string) => string) => maybe (AAL.name (wiki_entry))
                                                           (f)
                                                           (mname_add)

       switch (AAL.id (wiki_entry)) {
         case AdvantageId.immunityToPoison:
         case AdvantageId.immunityToDisease:
           return maybeMap (
             name_add => `${translate (staticData) ("advantagesdisadvantages.immunityto")} ${name_add}`
           )

         case AdvantageId.hatredOf:
           return maybeMap (
             name_add => `${translate (staticData) ("advantagesdisadvantages.hatredfor")} ${name_add}`
           )

         case DisadvantageId.afraidOf:
           return maybeMap (
             name_add => `${translate (staticData) ("advantagesdisadvantages.afraidof")} ${name_add}`
           )

         case DisadvantageId.principles:
         case DisadvantageId.obligations:
           return def (liftM2 ((level: number) => (name_add: string) =>
                               `${AAL.name (wiki_entry)} ${toRoman (level)} (${name_add})`)
                             (AOWIA.tier (hero_entry))
                             (mname_add))

         case SpecialAbilityId.gebieterDesAspekts:
           return maybeMap (name_add => `${AAL.name (wiki_entry)} ${name_add}`)

         case SpecialAbilityId.traditionArcaneBard:
         case SpecialAbilityId.traditionArcaneDancer:
         case SpecialAbilityId.traditionSavant: {
           return maybeMap (flip (addSndinParenthesis) (AAL.name (wiki_entry)))
         }

         default:
           return maybeMap (name_add => `${AAL.name (wiki_entry)} (${name_add})`)
       }
     }

   /**
    * Returns name, splitted and combined, of advantage/disadvantage/special
    * ability as a Maybe (in case the wiki entry does not exist).
    * @param instance The ActiveObject with origin id.
    * @param wiki The current hero's state.
    * @param l10n The locale-dependent messages.
    */
   export const getName =
     (staticData: StaticDataRecord) =>
     (hero_entry: Record<ActiveObjectWithId>): Maybe<Record<ActivatableCombinedName>> =>
       pipe (
             AOWIA.id,
             getWikiEntry (staticData),
             bindF<EntryWithCategory, Activatable> (ensure (isActivatableWikiEntry)),
             fmap ((wiki_entry: Activatable) => {
               const maddName = getEntrySpecificNameAddition (staticData)
                                                             (wiki_entry)
                                                             (hero_entry)

               const fullName = getEntrySpecificNameReplacements (staticData)
                                                                 (wiki_entry)
                                                                 (hero_entry)
                                                                 (maddName)

               return ActivatableCombinedName ({
                 name: fullName,
                 baseName: AAL.name (wiki_entry),
                 addName: maddName,
               })
             })
           )
           (hero_entry)

   /**
    * `compressList :: L10n -> [ActiveActivatable] -> String`
    *
    * Takes a list of active Activatables and merges them together. Used to display
    * lists of Activatables on character sheet.
    */
   export const compressList =
     (staticData: StaticDataRecord) =>
     (xs: List<Record<ActiveActivatable>>): string => {
       const grouped_xs =
         elems (groupByKey<Record<ActiveActivatable>, string> (AAA_.id) (xs))

       return pipe (
                     map (
                       ifElse<List<Record<ActiveActivatable>>>
                         (xs_group => flength (xs_group) === 1)
                         (pipe (listToMaybe, maybe ("") (AAA_.name)))
                         (xs_group => pipe (
                                             map ((x: Record<ActiveActivatable>) => {
                                               const levelPart =
                                                 pipe (
                                                       AAA_.level,
                                                       fmap (pipe (toRoman, appendStr (" "))),
                                                       fromMaybe ("")
                                                     )
                                                     (x)

                                               const selectOptionPart =
                                                 fromMaybe ("") (AAA_.addName (x))

                                               return selectOptionPart + levelPart
                                             }),
                                             sortStrings (staticData),
                                             intercalate (", "),
                                             x => ` (${x})`,
                                             x => maybe ("")
                                                       ((r: Record<ActiveActivatable>) =>
                                                         AAA_.baseName (r) + x)
                                                       (listToMaybe (xs_group))
                                           )
                                           (xs_group))
                     ),
                     sortStrings (staticData),
                     intercalate (", ")
                   )
                   (grouped_xs)
     } */
};
