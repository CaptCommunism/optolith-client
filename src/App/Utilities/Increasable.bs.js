// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Js_math = require("bs-platform/lib/js/js_math.js");
var Id$OptolithClient = require("../Constants/Id.bs.js");
var Int$OptolithClient = require("../../Data/Int.bs.js");
var ListH$OptolithClient = require("../../Data/ListH.bs.js");
var Maybe$OptolithClient = require("../../Data/Maybe.bs.js");
var IntMap$OptolithClient = require("../../Data/IntMap.bs.js");
var Activatable$OptolithClient = require("./Activatable.bs.js");
var Dependencies$OptolithClient = require("./Dependencies.bs.js");

function getValueDef(param) {
  return Maybe$OptolithClient.maybe(8, (function (x) {
                return x.value;
              }), param);
}

function getSkillCheckValues(mp, param) {
  return /* tuple */[
          getValueDef(Curry._2(IntMap$OptolithClient.lookup, param[0], mp)),
          getValueDef(Curry._2(IntMap$OptolithClient.lookup, param[1], mp)),
          getValueDef(Curry._2(IntMap$OptolithClient.lookup, param[2], mp))
        ];
}

var Attributes = {
  getValueDef: getValueDef,
  getSkillCheckValues: getSkillCheckValues
};

function getValueDef$1(param) {
  return Maybe$OptolithClient.maybe(8, (function (x) {
                return x.value;
              }), param);
}

function getExceptionalSkillBonus(exceptionalSkill, id) {
  return Maybe$OptolithClient.maybe(0, (function (x) {
                return ListH$OptolithClient.countBy((function (a) {
                              return Maybe$OptolithClient.Foldable.elem(id, Maybe$OptolithClient.listToMaybe(a.options));
                            }), x.active);
              }), exceptionalSkill);
}

function getMaxSrByCheckAttrs(mp, check) {
  var param = getSkillCheckValues(mp, check);
  return ListH$OptolithClient.Foldable.maximum(/* :: */[
              param[0],
              /* :: */[
                param[1],
                /* :: */[
                  param[2],
                  /* [] */0
                ]
              ]
            ]) + 2 | 0;
}

function getMaxSrFromEl(el, phase) {
  if (phase >= 2) {
    return /* Nothing */0;
  } else {
    return /* Just */[el.maxSkillRating];
  }
}

function getMax(el, phase, attrs, exceptionalSkill, staticEntry) {
  return getExceptionalSkillBonus(exceptionalSkill, /* `Skill */[
              290194801,
              staticEntry.id
            ]) + ListH$OptolithClient.Foldable.minimum(Maybe$OptolithClient.catMaybes(/* :: */[
                  /* Just */[getMaxSrByCheckAttrs(attrs, staticEntry.check)],
                  /* :: */[
                    getMaxSrFromEl(el, phase),
                    /* [] */0
                  ]
                ])) | 0;
}

function isIncreasable(el, phase, attrs, exceptionalSkill, staticEntry, heroEntry) {
  return heroEntry.value < getMax(el, phase, attrs, exceptionalSkill, staticEntry);
}

function getMinSrByCraftInstruments(craftInstruments, skills, staticEntry) {
  var match = Id$OptolithClient.unsafeSkillFromInt(staticEntry.id);
  if (match !== 50 && match !== 54) {
    return /* Nothing */0;
  }
  if (Activatable$OptolithClient.isActiveM(craftInstruments)) {
    var otherSkillId = match !== 50 ? /* Woodworking */50 : /* Metalworking */54;
    var otherSkillRating = getValueDef$1(Curry._2(IntMap$OptolithClient.lookup, Id$OptolithClient.skillToInt(otherSkillId), skills));
    return /* Just */[12 - otherSkillRating | 0];
  } else {
    return /* Nothing */0;
  }
}

function getMinSrByDeps(heroSkills, heroEntry) {
  return Maybe$OptolithClient.Functor.$less$amp$great(Maybe$OptolithClient.ensure(ListH$OptolithClient.Extra.notNull, Dependencies$OptolithClient.flatten((function (id) {
                        return getValueDef$1(Curry._2(IntMap$OptolithClient.lookup, id, heroSkills));
                      }), heroEntry.id, heroEntry.dependencies)), ListH$OptolithClient.Foldable.maximum);
}

function getMin(craftInstruments, heroSkills, staticEntry, heroEntry) {
  return Maybe$OptolithClient.Functor.$less$amp$great(Maybe$OptolithClient.ensure(ListH$OptolithClient.Extra.notNull, Maybe$OptolithClient.catMaybes(/* :: */[
                      getMinSrByDeps(heroSkills, heroEntry),
                      /* :: */[
                        getMinSrByCraftInstruments(craftInstruments, heroSkills, staticEntry),
                        /* [] */0
                      ]
                    ])), ListH$OptolithClient.Foldable.maximum);
}

function isDecreasable(craftInstruments, heroSkills, staticEntry, heroEntry) {
  return heroEntry.value > Maybe$OptolithClient.fromMaybe(0, getMin(craftInstruments, heroSkills, staticEntry, heroEntry));
}

function getMissingPoints(param) {
  return ListH$OptolithClient.Foldable.sum(ListH$OptolithClient.map((function (a) {
                    return Int$OptolithClient.max(0, 13 - a | 0);
                  }), /* :: */[
                  param[0],
                  /* :: */[
                    param[1],
                    /* :: */[
                      param[2],
                      /* [] */0
                    ]
                  ]
                ]));
}

function getBaseMinCheckMod(sr) {
  return (-Js_math.floor_int((sr - 1.0) / 3.0) | 0) + 3 | 0;
}

function getMinCheckModForRoutine(check, sr) {
  return Maybe$OptolithClient.Monad.$great$great$eq(Maybe$OptolithClient.ensure((function (param) {
                    return 0 > param;
                  }), sr), (function (sr) {
                var missingPoints = getMissingPoints(check);
                var checkModThreshold = getBaseMinCheckMod(sr);
                var dependentCheckMod = checkModThreshold + missingPoints | 0;
                if (dependentCheckMod < 4) {
                  return /* Just */[/* tuple */[
                            dependentCheckMod,
                            missingPoints > 0
                          ]];
                } else {
                  return /* Nothing */0;
                }
              }));
}

var Routine = {
  attributeThreshold: 13,
  getMissingPoints: getMissingPoints,
  getBaseMinCheckMod: getBaseMinCheckMod,
  getMinCheckModForRoutine: getMinCheckModForRoutine
};

var Skills = {
  getValueDef: getValueDef$1,
  getExceptionalSkillBonus: getExceptionalSkillBonus,
  getMaxSrByCheckAttrs: getMaxSrByCheckAttrs,
  getMaxSrFromEl: getMaxSrFromEl,
  getMax: getMax,
  isIncreasable: isIncreasable,
  getMinSrByCraftInstruments: getMinSrByCraftInstruments,
  getMinSrByDeps: getMinSrByDeps,
  getMin: getMin,
  isDecreasable: isDecreasable,
  Routine: Routine
};

function getMaxPrimaryAttributeValueById(heroAttrs, ps) {
  return ListH$OptolithClient.Foldable.maximum(ListH$OptolithClient.$less$plus$great(0, ListH$OptolithClient.map((function (p) {
                        return getValueDef(Curry._2(IntMap$OptolithClient.lookup, p, heroAttrs));
                      }), ps)));
}

function attributeValueToMod(value) {
  return Int$OptolithClient.max(0, (value - 8 | 0) / 3 | 0);
}

function getPrimaryAttributeMod(heroAttrs, ps) {
  return attributeValueToMod(getMaxPrimaryAttributeValueById(heroAttrs, ps));
}

function getValueDef$2(param) {
  return Maybe$OptolithClient.maybe(6, (function (x) {
                return x.value;
              }), param);
}

function getAttack(heroAttrs, staticEntry, heroEntry) {
  var ps = staticEntry.gr === 1 ? /* :: */[
      Id$OptolithClient.attributeToInt(/* Courage */0),
      /* [] */0
    ] : staticEntry.primary;
  return attributeValueToMod(getMaxPrimaryAttributeValueById(heroAttrs, ps)) + getValueDef$2(heroEntry) | 0;
}

function getParry(heroAttrs, staticEntry, heroEntry) {
  if (staticEntry.gr === Id$OptolithClient.combatTechniqueGroupToInt(/* Melee */0) && staticEntry.id !== Id$OptolithClient.combatTechniqueToInt(/* ChainWeapons */5) && staticEntry.id !== Id$OptolithClient.combatTechniqueToInt(/* Brawling */7)) {
    return /* Just */[attributeValueToMod(getMaxPrimaryAttributeValueById(heroAttrs, staticEntry.primary)) + Js_math.floor(Math.round(2.0 / getValueDef$2(heroEntry))) | 0];
  } else {
    return /* Nothing */0;
  }
}

function getExceptionalCombatTechniqueBonus(exceptionalCombatTechnique, id) {
  return Maybe$OptolithClient.maybe(0, (function (x) {
                return Maybe$OptolithClient.fromMaybe(0, Maybe$OptolithClient.Functor.$less$amp$great(Maybe$OptolithClient.listToMaybe(x.active), (function (a) {
                                  var hasBonus = Maybe$OptolithClient.Foldable.elem(/* `CombatTechnique */[
                                        -920806756,
                                        id
                                      ], Maybe$OptolithClient.listToMaybe(a.options));
                                  if (hasBonus) {
                                    return 1;
                                  } else {
                                    return 0;
                                  }
                                })));
              }), exceptionalCombatTechnique);
}

function getMaxCtrFromEl(el, phase) {
  if (phase >= 2) {
    return /* Nothing */0;
  } else {
    return /* Just */[el.maxCombatTechniqueRating];
  }
}

function getMax$1(el, phase, attrs, exceptionalCombatTechnique, staticEntry) {
  return getExceptionalCombatTechniqueBonus(exceptionalCombatTechnique, staticEntry.id) + ListH$OptolithClient.Foldable.minimum(Maybe$OptolithClient.catMaybes(/* :: */[
                  /* Just */[getMaxPrimaryAttributeValueById(attrs, staticEntry.primary)],
                  /* :: */[
                    getMaxCtrFromEl(el, phase),
                    /* [] */0
                  ]
                ])) | 0;
}

function isIncreasable$1(el, phase, attrs, exceptionalCombatTechnique, staticEntry, heroEntry) {
  return heroEntry.value < getMax$1(el, phase, attrs, exceptionalCombatTechnique, staticEntry);
}

function getMinCtrByHunter(onlyOneCombatTechniqueForHunter, staticEntry) {
  if (onlyOneCombatTechniqueForHunter && staticEntry.gr === Id$OptolithClient.combatTechniqueGroupToInt(/* Ranged */1)) {
    return /* Just */[10];
  } else {
    return /* Nothing */0;
  }
}

function getMinCtrByDeps(heroCombatTechniques, heroEntry) {
  return Maybe$OptolithClient.Functor.$less$amp$great(Maybe$OptolithClient.ensure(ListH$OptolithClient.Extra.notNull, Dependencies$OptolithClient.flatten((function (id) {
                        return getValueDef$2(Curry._2(IntMap$OptolithClient.lookup, id, heroCombatTechniques));
                      }), heroEntry.id, heroEntry.dependencies)), ListH$OptolithClient.Foldable.maximum);
}

function getMin$1(onlyOneCombatTechniqueForHunter, heroCombatTechniques, staticEntry, heroEntry) {
  return Maybe$OptolithClient.Functor.$less$amp$great(Maybe$OptolithClient.ensure(ListH$OptolithClient.Extra.notNull, Maybe$OptolithClient.catMaybes(/* :: */[
                      getMinCtrByDeps(heroCombatTechniques, heroEntry),
                      /* :: */[
                        getMinCtrByHunter(onlyOneCombatTechniqueForHunter, staticEntry),
                        /* [] */0
                      ]
                    ])), ListH$OptolithClient.Foldable.maximum);
}

function isDecreasable$1(onlyOneCombatTechniqueForHunter, heroCombatTechniques, staticEntry, heroEntry) {
  return heroEntry.value > Maybe$OptolithClient.fromMaybe(6, getMin$1(onlyOneCombatTechniqueForHunter, heroCombatTechniques, staticEntry, heroEntry));
}

var CombatTechniques = {
  getMaxPrimaryAttributeValueById: getMaxPrimaryAttributeValueById,
  attributeValueToMod: attributeValueToMod,
  getPrimaryAttributeMod: getPrimaryAttributeMod,
  getValueDef: getValueDef$2,
  getAttack: getAttack,
  getParry: getParry,
  getExceptionalCombatTechniqueBonus: getExceptionalCombatTechniqueBonus,
  getMaxCtrFromEl: getMaxCtrFromEl,
  getMax: getMax$1,
  isIncreasable: isIncreasable$1,
  getMinCtrByHunter: getMinCtrByHunter,
  getMinCtrByDeps: getMinCtrByDeps,
  getMin: getMin$1,
  isDecreasable: isDecreasable$1
};

var Spells = { };

var LiturgicalChants = { };

exports.Attributes = Attributes;
exports.Skills = Skills;
exports.CombatTechniques = CombatTechniques;
exports.Spells = Spells;
exports.LiturgicalChants = LiturgicalChants;
/* IntMap-OptolithClient Not a pure module */
