// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_int = require("bs-platform/lib/js/js_int.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Maybe$OptolithClient = require("./Maybe.bs.js");
var Either$OptolithClient = require("./Either.bs.js");
var Function$OptolithClient = require("./Function.bs.js");

var compare = Caml_obj.caml_compare;

var IntMap = $$Map.Make({
      compare: compare
    });

function foldr(f, initial, mp) {
  return Curry._3(IntMap.fold, (function (param, v, acc) {
                return Curry._2(f, v, acc);
              }), mp, initial);
}

function foldl(f, initial, mp) {
  return Curry._3(IntMap.fold, (function (param, v, acc) {
                return Curry._2(f, acc, v);
              }), mp, initial);
}

var toList = IntMap.bindings;

function $$null(mp) {
  return Curry._1(IntMap.is_empty, mp);
}

function elem(e, mp) {
  return Curry._2(IntMap.exists, (function (param, x) {
                return Caml_obj.caml_equal(e, x);
              }), mp);
}

function sum(mp) {
  return foldr((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, mp);
}

function product(mp) {
  return foldr(Caml_int32.imul, 1, mp);
}

function maximum(mp) {
  return foldr((function (prim, prim$1) {
                return Math.max(prim, prim$1);
              }), Js_int.min, mp);
}

function minimum(mp) {
  return foldr((function (prim, prim$1) {
                return Math.min(prim, prim$1);
              }), Js_int.max, mp);
}

function concat(mp) {
  return foldl(List.append, /* [] */0, mp);
}

function concatMap(f, mp) {
  return Curry._3(IntMap.fold, (function (param, v, acc) {
                return Curry._3(IntMap.union, (function (param, x, param$1) {
                              return Caml_option.some(x);
                            }), acc, Curry._1(f, v));
              }), mp, IntMap.empty);
}

function con(mp) {
  return Curry._2(IntMap.for_all, (function (param) {
                return Function$OptolithClient.$$const(Function$OptolithClient.id, param);
              }), mp);
}

function dis(mp) {
  return !Curry._2(IntMap.for_all, (function (param) {
                return Function$OptolithClient.$$const((function (prim) {
                              return !prim;
                            }), param);
              }), mp);
}

function any(pred, mp) {
  return !Curry._2(IntMap.for_all, (function (param, x) {
                return !Curry._1(pred, x);
              }), mp);
}

function all(pred, mp) {
  return Curry._2(IntMap.for_all, (function (param, x) {
                return Curry._1(pred, x);
              }), mp);
}

function notElem(e, mp) {
  return !elem(e, mp);
}

function find(pred, mp) {
  return Maybe$OptolithClient.Functor.$less$$great((function (prim) {
                return prim[1];
              }), Maybe$OptolithClient.optionToMaybe(Curry._2(IntMap.find_first_opt, (function (key) {
                        return Curry._1(pred, Function$OptolithClient.flip(IntMap.find, mp, key));
                      }), mp)));
}

var Foldable_length = IntMap.cardinal;

var Foldable = {
  foldr: foldr,
  foldl: foldl,
  toList: toList,
  $$null: $$null,
  length: Foldable_length,
  elem: elem,
  sum: sum,
  product: product,
  maximum: maximum,
  minimum: minimum,
  concat: concat,
  concatMap: concatMap,
  con: con,
  dis: dis,
  any: any,
  all: all,
  notElem: notElem,
  find: find
};

var member = IntMap.mem;

function notMember(key, mp) {
  return !Curry._2(member, key, mp);
}

function lookup(key, mp) {
  return Maybe$OptolithClient.Functor.$less$$great((function (prim) {
                return prim[1];
              }), Maybe$OptolithClient.optionToMaybe(Curry._2(IntMap.find_first_opt, (function (k) {
                        return k === key;
                      }), mp)));
}

function findWithDefault(def, key, mp) {
  return Maybe$OptolithClient.fromMaybe(def, lookup(key, mp));
}

var empty = IntMap.empty;

var insert = IntMap.add;

function insertWith(f, key, value, mp) {
  return Curry._3(insert, key, Maybe$OptolithClient.maybe(value, Curry._1(f, value), lookup(key, mp)), mp);
}

function insertWithKey(f, key, value, mp) {
  return Curry._3(insert, key, Maybe$OptolithClient.maybe(value, Curry._2(f, key, value), lookup(key, mp)), mp);
}

function insertLookupWithKey(f, key, value, mp) {
  var old = lookup(key, mp);
  return /* tuple */[
          old,
          Curry._3(insert, key, Maybe$OptolithClient.maybe(value, Curry._2(f, key, value), old), mp)
        ];
}

function adjust(f, key, mp) {
  return Curry._3(IntMap.update, key, (function (mx) {
                if (mx !== undefined) {
                  return Caml_option.some(Curry._1(f, Caml_option.valFromOption(mx)));
                }
                
              }), mp);
}

function adjustWithKey(f, key, mp) {
  return Curry._3(IntMap.update, key, (function (mx) {
                if (mx !== undefined) {
                  return Caml_option.some(Curry._2(f, key, Caml_option.valFromOption(mx)));
                }
                
              }), mp);
}

function update(f, key, mp) {
  return Curry._3(IntMap.update, key, (function (mx) {
                if (mx !== undefined) {
                  return Maybe$OptolithClient.maybeToOption(Curry._1(f, Caml_option.valFromOption(mx)));
                }
                
              }), mp);
}

function updateWithKey(f, key, mp) {
  return Curry._3(IntMap.update, key, (function (mx) {
                if (mx !== undefined) {
                  return Maybe$OptolithClient.maybeToOption(Curry._2(f, key, Caml_option.valFromOption(mx)));
                }
                
              }), mp);
}

function updateLookupWithKey(f, key, mp) {
  var old = lookup(key, mp);
  return /* tuple */[
          old,
          Curry._3(IntMap.update, key, (function (mx) {
                  if (mx !== undefined) {
                    return Maybe$OptolithClient.maybeToOption(Curry._2(f, key, Caml_option.valFromOption(mx)));
                  }
                  
                }), mp)
        ];
}

function alter(f, key, mp) {
  return Curry._3(IntMap.update, key, (function (mx) {
                return Maybe$OptolithClient.maybeToOption(Curry._1(f, Maybe$OptolithClient.optionToMaybe(mx)));
              }), mp);
}

function union(mp1, mp2) {
  return Curry._3(IntMap.union, (function (param, x, param$1) {
                return Caml_option.some(x);
              }), mp1, mp2);
}

function foldrWithKey(f, initial, mp) {
  return Curry._3(IntMap.fold, Curry.__3(f), mp, initial);
}

function foldlWithKey(f, initial, mp) {
  return Curry._3(IntMap.fold, (function (key, v, acc) {
                return Curry._3(f, acc, key, v);
              }), mp, initial);
}

function elems(mp) {
  return List.map((function (prim) {
                return prim[1];
              }), Curry._1(IntMap.bindings, mp));
}

function keys(mp) {
  return List.map((function (prim) {
                return prim[0];
              }), Curry._1(IntMap.bindings, mp));
}

function fromList(ps) {
  return List.fold_right((function (param) {
                return Curry._2(insert, param[0], param[1]);
              }), ps, empty);
}

function filter(pred, mp) {
  return Curry._2(IntMap.filter, (function (param, x) {
                return Curry._1(pred, x);
              }), mp);
}

function mapMaybe(f, mp) {
  return Curry._3(IntMap.fold, (function (k, x, acc) {
                var match = Curry._1(f, x);
                if (match) {
                  return Curry._3(insert, k, match[0], acc);
                } else {
                  return acc;
                }
              }), mp, empty);
}

function mapMaybeWithKey(f, mp) {
  return Curry._3(IntMap.fold, (function (k, x, acc) {
                var match = Curry._2(f, k, x);
                if (match) {
                  return Curry._3(insert, k, match[0], acc);
                } else {
                  return acc;
                }
              }), mp, empty);
}

function mapMEitherHelper(f, xs) {
  if (xs) {
    var match = xs[0];
    var new_value = Curry._1(f, match[1]);
    if (new_value.tag) {
      var match$1 = mapMEitherHelper(f, xs[1]);
      if (match$1.tag) {
        return /* Right */Block.__(1, [/* :: */[
                    /* tuple */[
                      match[0],
                      new_value[0]
                    ],
                    match$1[0]
                  ]]);
      } else {
        return /* Left */Block.__(0, [match$1[0]]);
      }
    } else {
      return /* Left */Block.__(0, [new_value[0]]);
    }
  } else {
    return /* Right */Block.__(1, [/* [] */0]);
  }
}

function mapMEither(f, mp) {
  return Either$OptolithClient.Functor.$less$$great(fromList, mapMEitherHelper(f, Curry._1(toList, mp)));
}

var Traversable = {
  mapMEither: mapMEither
};

var size = IntMap.cardinal;

var singleton = IntMap.singleton;

var $$delete = IntMap.remove;

var map = IntMap.map;

var mapWithKey = IntMap.mapi;

var assocs = IntMap.bindings;

var filterWithKey = IntMap.filter;

exports.Foldable = Foldable;
exports.size = size;
exports.member = member;
exports.notMember = notMember;
exports.lookup = lookup;
exports.findWithDefault = findWithDefault;
exports.empty = empty;
exports.singleton = singleton;
exports.insert = insert;
exports.insertWith = insertWith;
exports.insertWithKey = insertWithKey;
exports.insertLookupWithKey = insertLookupWithKey;
exports.$$delete = $$delete;
exports.adjust = adjust;
exports.adjustWithKey = adjustWithKey;
exports.update = update;
exports.updateWithKey = updateWithKey;
exports.updateLookupWithKey = updateLookupWithKey;
exports.alter = alter;
exports.union = union;
exports.map = map;
exports.mapWithKey = mapWithKey;
exports.foldrWithKey = foldrWithKey;
exports.foldlWithKey = foldlWithKey;
exports.elems = elems;
exports.keys = keys;
exports.assocs = assocs;
exports.fromList = fromList;
exports.filter = filter;
exports.filterWithKey = filterWithKey;
exports.mapMaybe = mapMaybe;
exports.mapMaybeWithKey = mapMaybeWithKey;
exports.Traversable = Traversable;
/* IntMap Not a pure module */
