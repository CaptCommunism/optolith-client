// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int32 = require("bs-platform/lib/js/int32.js");
var Int$OptolithClient = require("./Int.bs.js");
var ListH$OptolithClient = require("./ListH.bs.js");
var Function$OptolithClient = require("./Function.bs.js");

var IntMap = $$Map.Make({
      compare: Int32.compare
    });

function foldr(f, initial, mp) {
  return Curry._3(IntMap.fold, f, mp, initial);
}

function height(x) {
  if (x) {
    return x[0];
  } else {
    return 0;
  }
}

function bin(l, p, r) {
  return /* Bin */[
          Function$OptolithClient.on(Int$OptolithClient.max, height, l, r) + 1 | 0,
          l,
          p,
          r
        ];
}

function slope(x) {
  if (x) {
    return height(x[3]) - height(x[1]) | 0;
  } else {
    return 0;
  }
}

function rotateright(x) {
  if (x) {
    var match = x[1];
    if (match) {
      return bin(match[1], match[2], bin(match[3], x[2], x[3]));
    } else {
      return x;
    }
  } else {
    return x;
  }
}

function rotateleft(x) {
  if (x) {
    var match = x[3];
    if (match) {
      return bin(bin(x[1], x[2], match[1]), match[2], match[3]);
    } else {
      return x;
    }
  } else {
    return x;
  }
}

function rebalance(mp) {
  if (mp) {
    var tright = mp[3];
    var x = mp[2];
    var tleft = mp[1];
    var h = mp[0];
    var slope_main = slope(/* Bin */[
          h,
          tleft,
          x,
          tright
        ]);
    if (slope_main === 0 || slope_main === -1) {
      return /* Bin */[
              h,
              tleft,
              x,
              tright
            ];
    } else if (slope_main === -2) {
      return rotateright(/* Bin */[
                  h,
                  tleft,
                  x,
                  tright
                ]);
    } else if (slope_main === 1 && slope(tright) === 0) {
      return rotateleft(/* Bin */[
                  h,
                  tleft,
                  x,
                  tright
                ]);
    } else {
      return rotateleft(/* Bin */[
                  h,
                  tleft,
                  x,
                  rotateright(tright)
                ]);
    }
  } else {
    return /* Tip */0;
  }
}

function insert(k, x, mp) {
  if (mp) {
    var tright = mp[3];
    var match = mp[2];
    var k0 = match[0];
    var tleft = mp[1];
    if (k === k0) {
      return /* Bin */[
              mp[0],
              tleft,
              /* tuple */[
                k,
                x
              ],
              tright
            ];
    } else {
      var x0 = match[1];
      if (k < k0) {
        return rebalance(bin(insert(k, x, tleft), /* tuple */[
                        k0,
                        x0
                      ], tright));
      } else {
        return rebalance(bin(tleft, /* tuple */[
                        k0,
                        x0
                      ], insert(k, x, tright)));
      }
    }
  } else {
    return /* Bin */[
            1,
            /* Tip */0,
            /* tuple */[
              k,
              x
            ],
            /* Tip */0
          ];
  }
}

function foldr$1(f, _initial, _mp) {
  while(true) {
    var mp = _mp;
    var initial = _initial;
    if (mp) {
      _mp = mp[1];
      _initial = Curry._2(f, mp[2][1], foldr$1(f, initial, mp[3]));
      continue ;
    } else {
      return initial;
    }
  };
}

function toList(mp) {
  return foldr$1((function (x, xs) {
                return /* :: */[
                        x,
                        xs
                      ];
              }), /* [] */0, mp);
}

function fromList(ps) {
  return ListH$OptolithClient.Foldable.foldr((function (p, mp) {
                return insert(p[0], p[1], mp);
              }), /* Tip */0, ps);
}

var Experimental = {
  height: height,
  bin: bin,
  slope: slope,
  rotateright: rotateright,
  rotateleft: rotateleft,
  rebalance: rebalance,
  insert: insert,
  foldr: foldr$1,
  toList: toList,
  fromList: fromList
};

exports.IntMap = IntMap;
exports.foldr = foldr;
exports.Experimental = Experimental;
/* IntMap Not a pure module */
