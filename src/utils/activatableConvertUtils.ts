import R from 'ramda';
import * as Data from '../types/data.d';
import { List, OrderedMap, Record } from './dataUtils';
import { match } from './match';

/**
 * Converts the object generated by the list item to an object that can be
 * inserted into an array of ActiveObjects.
 * @param obj The entry for which you want to convert the object.
 * @param activate The object generated by the list item.
 */
export const convertUIStateToActiveObject =
  (activate: Data.ActivateArgs): Record<Data.ActiveObject> => {
    const { id, sel, sel2, input, tier, customCost } = activate;

    return Record.of(
        match<string, Data.ActiveObject>(id)
        .on('ADV_68', () => ({
          sid: sel,
          sid2: input
        }))
        .on('DISADV_33', () => ({
          sid: sel,
          ...(([7, 8].includes(sel as number) && input) ? { sid2: input } : {})
        }))
        .on('SA_9', () => ({
          sid: sel,
          sid2: input || sel2,
        }))
        .otherwise(() => R.pipe(
          (obj: Data.ActiveObject) => (sel !== undefined || input !== undefined) ? {
            ...obj,
            sid: input || sel,
          } : obj,
          obj => (obj.sid !== undefined && sel2 !== undefined) ? {
            ...obj,
            sid2: sel2,
          } : obj,
        )(tier !== undefined ? {
          tier,
        } : {}))
      )
        .mergeMaybe(
          Record.of({ cost: customCost })
        ) as Record<Data.ActiveObject>;
  };

/**
 * Generates a list of ActiveObjects based on the given instance.
 */
export const convertActivatableToArray = (
  obj: Record<Data.ActivatableDependent>,
): List<Record<Data.ActiveObjectWithId>> => {
  return obj.get('active')
    .mapWithIndex(index => e => e.merge(Record.of({
      id: obj.get('id'),
      index
    })));
};

/**
 * Get all active items in an array.
 * @param state A state slice.
 */
export const getActiveFromState = (
  state: OrderedMap<string, Record<Data.ActivatableDependent>>,
): List<Record<Data.ActiveObjectWithId>> => {
  return state.elems()
    .foldl<List<Record<Data.ActiveObjectWithId>>>(
      arr => e => arr.concat(convertActivatableToArray(e)),
      List.of()
    );
};

export interface ActiveObjectAny extends Data.ActiveObject {
  [key: string]: any;
}

/**
 * Returns only `sid`, `sid2` and `tier` property of passed `ActiveObject`.
 * @param activeObject
 */
export const getActiveObjectCore = (
  r: Record<ActiveObjectAny>,
): Record<Data.ActiveObject> => {
  return Record.of<Data.ActiveObject>({})
    .alter(() => r.lookup('sid'), 'sid')
    .alter(() => r.lookup('sid2'), 'sid2')
    .alter(() => r.lookup('tier'), 'tier');
};
